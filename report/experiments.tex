\subsection{Introduction}


We want to find out how ``good'' our MCTS strategy is for various numbers of iterations.
Of course we expect that it becomes better at higher numbers of iterations, but how many are necessary?
We would also want to know at what number, or even if, it becomes virtually perfect.


One way to find out when our MCTS algorithm becomes virtually perfect is to match it against a perfect opponent, i.e. a minimax strategy.
We can run perfect as First vs MCTS at $n$ iterations as Second many times, and see how many times MCTS will win, loose and tie.

We also want to classify the game being played as a first player win, second player win or neither player wins.
As discussed in section \ref{sec:minimax}, this means running perfect vs perfect for the game and recording the outcome.


\subsection{Classes of games to study}

The number of positional games grows rapidly with the number of vertices (or positions).
If we want to study interesting games of higher number of vertices, we are going to need to focus on particular classes.

In the experiment outlined below, we will focus on games which have hyper-edges (winning sets) with either two or three vertices.
In order to limit the number of vertices in a hyper-edge, we can use the arguments \texttt{-dm:n} and \texttt{-Dm:n} with \texttt{genbg}.
The argument \texttt{-dm:n} gives a lower bounds, $m$ and $n$, for the minimum degrees of the first and second classes of vertices, respectively.
Recall that the first class of vertices correspond to the vertices of the hyper-graph, and the second class refers to the hyper-edges, as described in \ref{sec:nautycommandline}.
Similarly, the argument \texttt{-Dm:n} gives upper bounds on the maximum degrees for the two classes.
Therefore, if we wanted to generate the class of hyper-graphs with 4 vertices and 2 hyper-edges which either have 2 or 3 vertices in them, we would run:

\begin{code}
  $ ./genbg -z 4 2 -d0:2 -D2:3 | ./showg

Graph 1, order 6.
  0 : 4 5;
  1 : 4;
  2 : 5;
  3 : ;
  4 : 0 1;
  5 : 0 2;

Graph 2, order 6.
  0 : 4;
  1 : 4;
  2 : 5;
  3 : 5;
  4 : 0 1;
  5 : 2 3;

Graph 3, order 6.
  0 : 4 5;
  1 : 4 5;
  2 : 5;
  3 : ;
  4 : 0 1;
  5 : 0 1 2;

Graph 4, order 6.
  0 : 4 5;
  1 : 4;
  2 : 5;
  3 : 5;
  4 : 0 1;
  5 : 0 2 3;

Graph 5, order 6.
  0 : 4 5;
  1 : 4 5;
  2 : 4;
  3 : 5;
  4 : 0 1 2;
  5 : 0 1 3;

\end{code}

\subsection{Experiment 1}
\label{sec:experiment1}

This chapter describes experiment 1. Mainly the setup and contents -- results are dealt with in the next chapter.
We are dealing with the set of all hypergraphs with hyperedges of size either two or three, from the following classes:

\begin{tabular}{ c | c }
\#vertices & \#hyperedges \\ \hline
2&1 \\ \hline
3&1-4 \\ \hline
4&1-10 \\ \hline
5&1-20 \\ \hline
6&1-13 \\ \hline
\end{tabular}

That ends up being about 4.3 million hypergraphs. 4320006, to be exact.

For each of those hypergraphs, we run three tournaments: minimax as first versus MCTS with 10, 20 and 30 iterations, as second.

Each tournament consists of 100 games. Within a given tournament, we record the number of first wins, second wins and the number of ties.
We also classify the games as first, second or neither player win, by playing two optimal players against each other and recording the result.
This all ends up in a big database, which is discussed more in detail in chapter \ref{sec:database_queries}.
